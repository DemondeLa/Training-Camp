## Blog

### 算法

#### 详细布置

- 151 翻转字符串里的单词
- 卡码网：55 右旋转字符串
- 28 实现 strStr()
- 459 重复的子字符串
- 字符串总结 
- 双指针回顾 



#### 151 翻转字符串里的单词

建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。 

题目链接/文章讲解/视频讲解：

https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html

看到题目，首先想到的就是使用`vector<string>`将每个单词存下来，然后逆序输出

对于双指针的方法，一开始想到的是使用4个指针，但是移动后比较混乱，没有思路

在看了随想录后，发现本题就是可以拆分为2部分一个是逆置，一个是去除多余的空格。逆置的思路以前有看到过，但是没有想到，就是先整体逆置，在对每个单词进行逆置；去除多余的空格使用快慢指针的思路，之前数组题的之后carl哥也有讲过

```cpp
class Solution {
public:
    void removeSpace(string& s) {
        int slow = 0, fast;
        for (fast = 0; fast < s.size(); ++fast) {
            if (s[fast] != ' ') {
                if (slow > 0)
                    s[slow++] = ' ';
                while (fast < s.size() && s[fast] != ' ')
                    s[slow++] = s[fast++];
            }
        }
        s.resize(slow);
    }

    void reverse(string& s, int start, int end) {
        while (start < end)
            std::swap(s[start++], s[end--]);
    }

    string reverseWords(string s) {
        removeSpace(s);
        reverse(s, 0, s.size() - 1);
        int start = 0, end;
        for (end = 0; end <= s.size(); ++end)
            if (end == s.size() || s[end] == ' ') {
                reverse(s, start, end - 1);
                start = end + 1;
            }
        return s;
    }
};
```

在写这道题的时候，坑还是比较多的，去除空格的时候，去除的是多余的空格，记得第一个单词前面是没有空格的，以及去除后不要忘记`resize`；另外在逆置时，之前用双重`while`，一个找单词的开始，另一个找结束，完全没有必要，还会超时



#### 卡码网：55 右旋转字符串

建议：题解中的解法如果没接触过的话，应该会想不到

题目链接/文章讲解/视频讲解：

https://programmercarl.com/kamacoder/0055.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html

一开始的想法是将整个字符串向后移动`k`位，然后将末尾的`k`个字符移动到整个字符串的前面

```cpp
#include <iostream>
 
int main() {
    int k;
    std::string s;
    std::cin >> k >> s;
    int index = s.size() - 1;
    int len = s.size();
    s.resize(s.size() + k);
    for (; index >= 0; --index) 
        s[index + k] = s[index];
    for (int i = 0; i < k; ++i)
        s[i] = s[i + len];
    s.resize(len);
    std::cout << s;
    return 0;
}
```

而随想录中的解法，和前一题的逆序思路一样，整体逆置，再对两个子串逆置

```cpp
#include <iostream>
 
void reverse(std::string &s, int start, int end) {
    while (start < end)
        std::swap(s[start++], s[end--]);
}
 
int main() {
    int k;
    std::string s;
    std::cin >> k >> s;
     
    reverse(s, 0, s.size() - 1);
    reverse(s, 0, k - 1);
    reverse(s, k, s.size() - 1);
     
    std::cout << s;
     
    return 0;
}
```



#### KMP算法

它用来解决字符串匹配的问题，即在文本串中是否出现过模式串

核心思想：

1. **部分匹配表（Partial Match Table，简称PMT），也叫前缀表**：
   - 用于记录模式字符串的每个位置前缀和后缀的最大相等长度。
   - 通过这个表，KMP算法在发现不匹配时，可以跳过一些已经匹配的字符，而不需要从头开始重新匹配。
2. **跳过已知的匹配部分**：
   - 如果匹配失败，模式串可以根据部分匹配表的信息，直接移动到下一个可能的匹配位置，而无需回退文本串中的指针。

步骤：

1. 构建部分匹配表（PMT）

PMT记录的是模式串每个位置之前的最长相等前后缀长度。
设模式串为 `P[0..m-1]`，构建一个数组 `next[]`，其定义为：
`next[i]` 表示模式串中从 `0` 到 `i` 的子串的最长相等前后缀长度。

构建规则：

- 如果 `P[i] == P[j]`（当前字符匹配），则 `next[i + 1] = j + 1`。
- 如果 `P[i] != P[j]`，通过 `next[j]` 回退，直到找到一个匹配前后缀，或者退到 `j = 0`。

2. 进行字符串匹配

- 用两个指针分别指向文本串和模式串，开始匹配。
- 匹配成功则移动两个指针。
- 匹配失败时，使用 `next[]` 表跳转模式串位置，而文本串指针保持不变。



#### 28 实现 strStr()

因为KMP算法很难，大家别奢求 一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会 好懂很多。

或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。

因为大家 算法能力还没到，细扣 很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有 算法基础和思维了，在看多看几遍视频，慢慢就理解了。

题目链接/文章讲解/视频讲解：

https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html

没有看懂随想录的视频，主要是没有看懂为什么`next[i] = j`

https://www.youtube.com/watch?v=3IFxpozBs2I 有解释推导的过程

KMP算法分为两个部分，第一步是先求出prefix table，也就是前缀表；然后根据求出的前缀表来完成整个KMP的搜索

生成前缀表：

1. 初始化

- 创建一个长度为 `m` 的数组 `next`，初始值为 `0`。
- 设置一个指针 `j = 0`，表示当前最长前缀长度。
- 遍历模式串的每个字符 `s[i]`，从 `i = 1` 开始计算。

2. 转移规则

对每个 `i`：

1. 如果

   `s[i] == s[j]`，表示当前位置的前后缀可以继续扩展：

   - 更新 `next[i] = j + 1`。
   - 然后令 `j = j + 1` 继续匹配。

2. 如果`s[i] != s[j]`，前后缀不匹配：

   - 如果 `j > 0`，利用 `next[j - 1]` 回退到前一个匹配的位置继续比较。
   - 如果 `j == 0`，说明当前字符无法扩展，直接令 `next[i] = 0`。

> 生成前缀表的关键点
>
> 1. 如何回退（跳转）
>    当字符不匹配时，通过 `next[j-1]` 找到之前的最长相等前后缀，继续尝试匹配。
>    这样可以避免从头开始匹配，提升效率。
>
> 2. 为什么第一个值始终为0
>    因为模式串的第一个字符没有任何前缀或后缀，所以 `next[0] = 0`。
>
> 3. 优化版前缀表
>    在KMP的实际应用中，有时会将 `next[i]` 调整为 `next[i] - 1`，避免多余的匹配过程（称为优化版 next 表）。在这种情况下：
>
>    `next[i]` 表示：当前字符匹配失败时，应该跳转到的位置。
>

使用KMP算法进行匹配

1. 匹配过程：

   - 使用两个指针：
     - `i` 指向文本串（主串）的位置。
     - `j` 指向模式串的位置。
   - 如果 `text[i] == pattern[j]`，说明字符匹配，两个指针同时前进。
   - 如果 `text[i] != pattern[j]`：
     - 如果 `j = -1`，说明模式串第一个字符就不匹配，文本串指针 `i` 右移。
     - 否则，利用 `next[j]`，将模式串指针 `j` 跳转到合适的位置
2. 匹配完成：
   - 如果 `j == m`，说明模式串完全匹配，记录匹配起始位置。
   - 继续尝试寻找下一个匹配。

```cpp
class Solution {
public:
    vector<int> getNext(const string &s) {
        vector<int> next(s.size(), 0);
        int j = -1; // 初始化 j 为 -1
        next[0] = -1; // 第一个位置固定为 -1

        for (int i = 1; i < s.size(); ++i) {
            // 回退到合适的位置
            while (j != -1 && s[i] != s[j + 1]) {
                j = next[j];
            }
            // 如果当前字符匹配，j++
            if (s[i] == s[j + 1]) {
                j++;
            }
            // 更新 next 数组
            next[i] = j;
        }
        return next;
    }

    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;

        vector<int> next = getNext(needle); // 构造 next 数组
        int j = -1; // 初始化模式串指针

        for (int i = 0; i < haystack.size(); ++i) {
            // 回退到合适的位置
            while (j != -1 && haystack[i] != needle[j + 1]) {
                j = next[j];
            }
            // 如果当前字符匹配，j++
            if (haystack[i] == needle[j + 1]) {
                j++;
            }
            // 如果模式串完全匹配
            if (j == needle.size() - 1) {
                return i - j; // 返回匹配起始位置
            }
        }
        return -1; // 未匹配返回 -1
    }
};
```

理解的算法，但是自己没有写出来，跟着敲了一遍



#### 459 重复的子字符串

本题算是KMP算法的一个应用，不过 对KMP了解不够熟练的话，理解本题就难很多。 

我的建议是 **KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃**

题目链接/文章讲解/视频讲解：

https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html

KMP算法没有完全掌握，听了Carl哥的课，可以使用两个字符串相加，再去除前后，再判断子串的方法，因为如果一个字符串是由多个子串构成的，那么`s + s`在去除前后的元素后，中间一定存在子串

```cpp
bool repeatedSubstringPattern(string s) {
	string ss(s.begin() + 1, s.end());
	ss.insert(ss.end(), s.begin(), s.end() - 1);
	return ss.find(s) != string::npos;
}
```





#### 字符串总结 

 比较简单，大家读一遍就行 

题目链接/文章讲解：

https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html

字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。

`vector<char>` 和 `string`，在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有

#### 双指针回顾 

此时我们已经做过10道双指针的题目了，来一起回顾一下，大家自己也总结一下双指针的心得 

文章讲解：

https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95

**双指针法在数组，链表和字符串中很常用**

**很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作**

七道双指针相关的题目了分别是：

- [27.移除元素](https://programmercarl.com/0027.移除元素.html)
- [15.三数之和](https://programmercarl.com/0015.三数之和.html)
- [18.四数之和](https://programmercarl.com/0018.四数之和.html)
- [206.翻转链表](https://programmercarl.com/0206.翻转链表.html)
- [142.环形链表II](https://programmercarl.com/0142.环形链表II.html)
- [344.反转字符串](https://programmercarl.com/0344.反转字符串.html)

双指针法是一种通过使用两个指针来遍历数组、链表或字符串的算法思想。根据应用场景的不同，双指针主要有两种常见形式：

1. **对撞指针（Two Pointers）：** 一个指针从头开始，一个指针从尾部开始，逐步向中间靠拢。
2. **快慢指针（Two-Speed Pointers）：** 一个指针移动得快，另一个指针移动得慢，用于处理链表等问题。



### 八股文

#### DNS 查询过程

掌握程度：

- 了解 DNS 概念及其作用
- 能够清晰地描述DNS查询的基本过程，包括递归查询和迭代查询。
- 知道DNS查询可能涉及的不同层级的DNS服务器。

参考资料：
 [技术蛋老师：【DNS域名解析过程】]()

https://www.bilibili.com/video/BV1uL4y1B7aE/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80

[小林coding: DNS域名解析过程]()

https://xiaolincoding.com/network/1_base/what_happen_url.html#真实地址查询-dns



在委托操作系统发送消息时，必须提供通信对象的 IP 地址，而通过域名是不能将消息发送给`Web`服务器的

`DNS` 服务器：保存了 `Web` 服务器域名与 `IP` 的对应关系

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。在域名中，**越靠右**的位置表示其层级**越高**。

实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表根域名。

也就是`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。

这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。

因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

##### 域名解析的工作流程

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。权威这一级指`bilibili`、`baidu`、`qq`等
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

![](pic/4_7.png)

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。



#### CDN是什么

掌握程度：

- 能够清晰地描述CDN的概念、工作原理和主要优势。
- 理解CDN的关键组件和缓存策略。
- 知道CDN在提高网站性能和用户体验方面的作用。

参考资料：
[【什么是CDN？CDN能为我们做什么？我们为什么要了解他？】 ](https://www.bilibili.com/video/BV1jS4y197zi/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)



CDN（Content Delivery Network）是由多个分布在不同地理位置的服务器组成的网络。其核心目标是**将用户请求的内容（如网页、图片、视频等）尽可能快速且可靠地传递到用户手中**，通过减少网络延迟和服务器负载提升访问速度和稳定性。

##### CDN的工作原理

1. **内容缓存**：
   - 网站的静态内容（如HTML、CSS、JS文件，图片和视频等）被分发并缓存到CDN的边缘节点服务器中。
   - 当用户发起请求时，CDN会通过DNS解析用户的请求并将其路由到离用户最近的边缘节点，从而减少延迟。
2. **请求路由**：
   - 当用户访问网站时，请求首先被发送到CDN服务。
   - CDN根据用户的地理位置、网络状况等动态选择一个最优的节点来响应请求。
3. **回源机制**：
   - 如果边缘节点没有缓存请求的内容（即缓存未命中），CDN会向源站（即原始服务器）发起请求，获取最新内容并将其缓存到节点，以供后续用户访问。

##### CDN的关键组件

边缘节点（Edge Nodes）：分布在不同地理位置的服务器，直接为用户提供服务。

缓存服务器（Cache Servers）：存储缓存内容，负责快速响应用户请求。

分发控制中心：监控和管理整个CDN系统，决定内容分发和节点选择。

回源服务器（Origin Server）：存储网站的原始内容，当CDN节点缺少内容时，向回源服务器请求。

监控和分析工具：用于监测CDN性能和流量，优化内容分发策略。

##### CDN的缓存策略

CDN的缓存策略决定了内容在节点上的存储时间和更新方式

1. **时间到期策略（Time-to-Live, TTL）**：

   在缓存中为每个文件设置一个有效期（如60分钟）。过期后，节点会从源站拉取最新内容。

2. **验证缓存策略**：

   在用户请求时，边缘节点向源站验证内容是否有更新，只有内容更新时才重新拉取。

3. **分层缓存**：

   缓存服务器分为多个层级，比如区域级缓存和全球级缓存，减少对源站的直接访问。

4. **按需缓存**：

   仅对用户经常访问的内容进行缓存，减少不必要的存储和流量消耗。

##### CDN的作用：

- 提高网站性能：

  - 通过将内容缓存到离用户更近的服务器节点，显著降低了页面加载时间，提升用户体验
- 通过分布式架构，CDN能有效处理海量用户的同时访问。
- 降低服务器负载：

  - 减少了源站的直接访问压力，防止服务器因高并发访问而宕机
- 提升全球访问速度：

  - 即使用户身处不同地区，CDN都能提供快速响应，从而改善跨地域访问性能。
- CDN节点的地理分布性减少了网络的物理距离和传输时间。
- 增强可靠性：
  - CDN具有多节点冗余机制，即使部分节点故障，其他节点仍能继续提供服务
  - 即使源站发生问题，CDN也可以通过缓存的内容继续提供服务。

- 节省带宽成本：
  - 减少了回源请求频率，从而降低了源站的带宽消耗。

- 增强安全性：
  - 通过内置的防护措施（如DDoS防护、WAF等），有效防止恶意攻击和流量劫持
- 流媒体优化：
  - CDN支持渐进式加载和分片传输，确保流媒体内容的平滑播放



#### Cookie和Session是什么？有什么区别？

掌握程度：

- 能够清晰地描述Cookie和Session的定义、存储位置、生命周期、大小限制和安全性。
- 理解Cookie和Session的使用场景和它们在Web应用中的不同作用。
- 能够讨论Cookie和Session的安全性问题以及如何提高它们的安全性。

扩展：

- 结合案例讨论Cookie和Session的使用
- 了解如何通过设置HttpOnly、Secure标志，以及使用SameSite属性来提高Cookie的安全性

参考资料：
[【Cookie、Session、Token究竟区别在哪？如何进行身份认证，保持用户登录状态？】 ](https://www.bilibili.com/video/BV1ob4y1Y7Ep/?share_source=copy_web)



##### Cookie

HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

##### Session

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

##### Cookie 和 Session 的对比

| 特性     | Cookie                                                       | Session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 作用范围 | 客户端（浏览器）                                             | 服务器端                                                     |
| 存取方式 | 只能保存ASCII                                                | 可以保存任意数据类型（一般保存一些常用变量信息如UserId）     |
| 生命周期 | 可以设置有效期，长时间保持。默认为会话级别，浏览器关闭失效；持久 Cookie 会有明确的到期时间（如设置默认登录）。 | 默认与会话相同（浏览器关闭失效），也可以设置超时时间。一般失效时间较短 |
| 大小限制 | 每个 Cookie 最大约为 4KB，总数通常限制在 20-50 个（浏览器依赖）。 | 理论上没有限制，但受服务器内存和性能影响。                   |
| 安全性   | 存储在客户端，容易被窃取（如 XSS 攻击）；传输中可能被监听（如果未加密）。 | 较为安全，存储在服务端，仅保留 Session ID 在客户端。         |
| 使用场景 | 存储用户偏好（如语言设置）、跨页面跟踪用户、轻量级信息。     | 存储用户认证信息、会话相关重要数据（如购物车）。             |

##### 为什么需要 Cookie 和 Session

浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是哪个用户在和服务端打交道，此时，需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态

既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中==禁止了 Cookie==，如何保障整个机制的正常运转。

- 第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 `xxx?SessionID=123456...`。

- 第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。

  Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。

当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证

##### 如何考虑分布式 Session 问题？

互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：（建议采用第三种方案）

- Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
- Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- 共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致

##### 如何解决跨域请求？Jsonp 跨域的原理是什么

> 同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。
>
> 所谓的“同源”指的是“三个相同”：协议相同、域名相同、端口相同。只有这三个完全相同，才算是同源。即便两个不同的域名指向同一个 ip 地址，也非同源
>
> 同源策略的目的：是为了保证用户信息的安全，防止恶意的网站窃取数据。

同源策略保证了一定的安全性，但在某些场景下也带来了不便，比如常见的跨域请求问题。

在HTML中，<a>,<form>, <img>, <script>, <iframe>, <link> 等标签以及Ajax都可以指向一个资源地址，而所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。同源即同域，三项有一项不同便会出现跨域请求。

浏览器会对跨域请求做出限制，因为跨域请求可能会被利用发动CSRF攻击。

CSRF（Cross-site request forgery），即“跨站请求伪造”，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。

解决跨域请求的常用方法是：

- 通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。
- 通过 Jsonp 跨域
- 其它跨域解决方案

浏览器的同源策略把跨域请求都禁止了，但是页面中的 `<script><img><iframe>`标签是例外，不受同源策略限制。Jsonp 就是利用 `<script>` 标签跨域特性进行跨域数据访问。

JSONP（**JSON with Padding**）是一种跨域数据请求的解决方案，主要用于浏览器环境中。它是对JSON（JavaScript Object Notation）的一种扩展，通过利用`<script>`标签的跨域特性实现跨域数据请求

JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。

JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求



### 总结

在今天的算法题中，学到了一个奇技淫巧，逆置整个字符串，再逆置子串，从而负负得正

另外，对于KMP算法只是理解了原理，但是代码还是不能写出来。需要多手动模拟，总结规律
